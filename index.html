<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Lisa's Bibliotheca v2.9</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Clean, Modern Design */
            --primary-color: #3b82f6;
            --primary-hover: #2563eb;
            --background: #f8fafc;
            --card-bg: #ffffff;

            /* Format Badge Colors (subtle) */
            --physical-color: #3b82f6;
            --electronic-color: #8b5cf6;
            --audio-color: #f59e0b;

            /* Text Colors */
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;

            /* UI Elements */
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.07);
            --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.1);
            --radius: 8px;

            /* Cover Colors */
            --cover-1: #e0e7ff;
            --cover-2: #dbeafe;
            --cover-3: #ccfbf1;
            --cover-4: #fef3c7;
            --cover-5: #fce7f3;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header Styles */
        header {
            background:
                linear-gradient(135deg, rgba(59, 130, 246, 0.9) 0%, rgba(99, 102, 241, 0.9) 100%),
                url('data:image/svg+xml,<svg width="60" height="60" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="grid" x="0" y="0" width="60" height="60" patternUnits="userSpaceOnUse"><path d="M 60 0 L 0 0 0 60" fill="none" stroke="rgba(255,255,255,0.05)" stroke-width="1"/></pattern></defs><rect width="60" height="60" fill="url(%23grid)"/></svg>');
            background-size: cover, 60px 60px;
            padding: 32px 35px;
            border-radius: 16px;
            box-shadow:
                0 8px 32px rgba(59, 130, 246, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        h1 {
            font-size: 2.25rem;
            font-weight: 700;
            color: white;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
            text-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
            letter-spacing: -0.01em;
        }

        .stats-bar {
            display: flex;
            gap: 12px;
            margin-bottom: 18px;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 14px 20px;
            border-radius: 12px;
            flex: 1;
            min-width: 130px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.85);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }

        .stat-value {
            font-size: 1.875rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 1px 8px rgba(0, 0, 0, 0.15);
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }

        .header-actions .btn {
            background: rgba(255, 255, 255, 0.9);
            color: #3b82f6;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .header-actions .btn:hover {
            background: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        }

        .header-actions .btn-primary {
            background: white;
            color: #6366f1;
        }

        .header-actions .btn-primary:hover {
            background: white;
            color: #4f46e5;
            box-shadow: 0 4px 16px rgba(99, 102, 241, 0.25);
        }

        /* Button Styles */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-secondary {
            background: var(--background);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--card-bg);
            border-color: var(--text-muted);
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.875rem;
        }

        .btn-danger {
            background: #9ca3af;
            color: white;
        }

        .btn-danger:hover {
            background: #6b7280;
        }

        /* Controls Section */
        .controls {
            background: var(--card-bg);
            padding: 20px;
            border-radius: var(--radius);
            box-shadow: var(--shadow-md);
            margin-bottom: 30px;
        }

        .controls-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .search-box {
            flex: 1;
            min-width: 200px;
            position: relative;
        }

        .search-box input {
            width: 100%;
            padding: 10px 40px 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            font-size: 1rem;
            font-family: inherit;
            transition: border-color 0.2s;
        }

        .search-box input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .search-clear {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--text-muted);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .search-clear:hover {
            background: var(--text-secondary);
        }

        .search-clear.visible {
            display: flex;
        }

        .filter-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 8px 16px;
            border: 1px solid var(--border-color);
            background: var(--card-bg);
            border-radius: var(--radius);
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-secondary);
        }

        .filter-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .filter-btn.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            font-size: 0.875rem;
            font-family: inherit;
            background: var(--card-bg);
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* Month Section */
        .month-section {
            margin-bottom: 40px;
        }

        .month-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            cursor: pointer;
            user-select: none;
        }

        .month-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .month-count {
            font-size: 0.875rem;
            color: var(--text-secondary);
            background: var(--background);
            padding: 4px 12px;
            border-radius: 20px;
        }

        /* Books Grid */
        .books-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 24px;
            margin-bottom: 20px;
        }

        /* Book Card */
        .book-card {
            background: var(--card-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            transition: all 0.3s ease;
            display: flex !important;
            flex-direction: row !important;
            flex-wrap: nowrap !important;
            padding: 20px;
            gap: 15px;
            align-items: flex-start;
        }

        .book-card:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        .book-cover {
            width: 100px !important;
            min-width: 100px !important;
            height: 150px;
            border-radius: 4px;
            flex-shrink: 0 !important;
            overflow: hidden;
            background: var(--background);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
        }

        .book-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .book-content-wrapper {
            flex: 1 !important;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 0;
        }

        .book-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .book-author {
            font-size: 0.938rem;
            color: var(--text-secondary);
        }

        .book-meta {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .badge-format {
            color: white;
        }

        .badge-format.physical {
            background: var(--physical-color);
        }

        .badge-format.electronic {
            background: var(--electronic-color);
        }

        .badge-format.audio {
            background: var(--audio-color);
        }

        .badge-genre {
            background: var(--background);
            color: var(--text-secondary);
        }

        .badge-date {
            background: var(--background);
            color: var(--text-secondary);
        }

        .book-synopsis {
            font-size: 0.875rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .synopsis-text {
            margin-bottom: 8px;
        }

        .synopsis-toggle {
            color: var(--primary-color);
            cursor: pointer;
            font-weight: 500;
            background: none;
            border: none;
            padding: 0;
            font-size: 0.875rem;
        }

        .synopsis-toggle:hover {
            text-decoration: underline;
        }

        .book-actions {
            display: flex !important;
            flex-direction: column !important;
            gap: 10px;
            flex-shrink: 0 !important;
            align-self: flex-start;
            width: 80px !important;
            min-width: 80px !important;
        }

        .book-actions .btn {
            width: 80px !important;
            padding: 8px 12px;
            white-space: nowrap;
            font-size: 0.813rem;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--card-bg);
            border-radius: var(--radius);
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-body {
            padding: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .form-label .required {
            color: #ef4444;
        }

        .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            font-size: 1rem;
            font-family: inherit;
            transition: border-color 0.2s;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-input.error {
            border-color: #ef4444;
        }

        .error-message {
            color: #ef4444;
            font-size: 0.75rem;
            margin-top: 4px;
        }

        textarea.form-input {
            resize: vertical;
            min-height: 100px;
        }

        .char-count {
            text-align: right;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .lookup-section {
            margin-bottom: 20px;
            padding: 15px;
            background: var(--background);
            border-radius: var(--radius);
            text-align: center;
        }

        .lookup-btn {
            background: #10b981;
            color: white;
        }

        .lookup-btn:hover {
            background: #059669;
        }

        .lookup-btn:disabled {
            background: var(--text-muted);
            cursor: not-loading;
            transform: none;
        }

        .lookup-status {
            margin-top: 10px;
            font-size: 0.875rem;
            padding: 8px 12px;
            border-radius: var(--radius);
            display: none;
        }

        .lookup-status.loading {
            display: block;
            background: #dbeafe;
            color: #1e40af;
        }

        .lookup-status.success {
            display: block;
            background: #d1fae5;
            color: #065f46;
        }

        .lookup-status.error {
            display: block;
            background: #fee2e2;
            color: #991b1b;
        }

        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #93c5fd;
            border-top-color: #1e40af;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .radio-group {
            display: flex;
            gap: 15px;
        }

        .radio-option {
            flex: 1;
        }

        .radio-option input {
            display: none;
        }

        .radio-option label {
            display: block;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: var(--radius);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
        }

        .radio-option input:checked + label {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
        }

        .cover-preview {
            margin-top: 10px;
            width: 120px;
            height: 180px;
            border-radius: var(--radius);
            overflow: hidden;
            background: var(--background);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cover-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .modal-footer {
            padding: 24px;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Reports */
        .reports-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .report-section h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--border-color);
        }

        .report-bars {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .report-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .report-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
        }

        .report-genre-name {
            font-weight: 500;
            color: var(--text-primary);
        }

        .report-count {
            color: var(--text-secondary);
            font-size: 0.8125rem;
        }

        .report-bar-container {
            width: 100%;
            height: 24px;
            background: var(--background);
            border-radius: 4px;
            overflow: hidden;
        }

        .report-bar {
            height: 100%;
            background: var(--primary-color);
            border-radius: 4px;
            transition: width 0.3s ease;
            min-width: 2px;
        }

        .report-bar.physical {
            background: var(--physical-color);
        }

        .report-bar.electronic {
            background: var(--electronic-color);
        }

        .report-bar.audio {
            background: var(--audio-color);
        }

        /* Dynamic Report Controls */
        .report-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 25px;
            background: var(--background);
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .report-select {
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            font-size: 0.938rem;
            font-family: inherit;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.2s;
        }

        .report-select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .report-select:hover {
            border-color: var(--primary-hover);
        }

        #dynamic-report-container {
            min-height: 200px;
        }

        .report-matrix {
            margin-top: 20px;
        }

        .report-matrix-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--primary-color);
        }

        .matrix-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--card-bg);
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .matrix-table th {
            background: var(--primary-color);
            color: white;
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            font-size: 0.875rem;
        }

        .matrix-table td {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.875rem;
        }

        .matrix-table tr:last-child td {
            border-bottom: none;
        }

        .matrix-table tr:hover {
            background: var(--background);
        }

        .matrix-table .row-header {
            font-weight: 600;
            color: var(--text-primary);
            background: var(--background);
        }

        .matrix-table .count-cell {
            text-align: center;
            font-weight: 600;
            color: var(--primary-color);
        }

        .matrix-table .total-row {
            background: var(--background);
            font-weight: 700;
        }

        .single-dimension-report {
            margin-top: 20px;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.25rem;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .empty-state p {
            font-size: 1rem;
        }

        /* Bulk Update Mode */
        .bulk-update-btn {
            background: var(--background);
            color: var(--text-primary);
            padding: 8px 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .bulk-update-btn:hover {
            background: var(--card-bg);
            border-color: var(--text-muted);
        }

        .bulk-update-btn.active {
            background: #10b981;
            color: white;
            border-color: #10b981;
        }

        .bulk-update-btn.active:hover {
            background: #059669;
            border-color: #059669;
        }

        .bulk-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            margin-right: 5px;
        }

        .bulk-select-container {
            display: none;
            align-items: center;
        }

        .bulk-select-container.active {
            display: flex;
        }

        .bulk-action-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--card-bg);
            padding: 20px;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
            border-top: 2px solid var(--primary-color);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .bulk-action-bar.active {
            display: flex;
        }

        .bulk-action-bar .selected-count {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 1rem;
        }

        .bulk-action-bar .btn {
            margin: 0;
        }

        /* Hidden utility */
        .hidden {
            display: none !important;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .books-grid {
                grid-template-columns: 1fr;
            }

            header {
                padding: 24px 20px;
            }

            .stats-bar {
                flex-direction: column;
            }

            .stat-item {
                width: 100%;
            }

            h1 {
                font-size: 1.75rem;
            }

            .controls-row {
                flex-direction: column;
                align-items: stretch;
            }

            .filter-group {
                width: 100%;
            }

            .filter-btn {
                flex: 1;
            }

            .book-card {
                flex-direction: column;
            }

            .book-actions {
                flex-direction: row;
                align-self: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header>
            <h1>Lisa's Bibliotheca</h1>
            <div class="stats-bar">
                <div class="stat-item">
                    <div class="stat-label">Total Books</div>
                    <div class="stat-value" id="stat-total">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">This Month</div>
                    <div class="stat-value" id="stat-month">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">This Year</div>
                    <div class="stat-value" id="stat-year">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Reading Streak</div>
                    <div class="stat-value" id="stat-streak">0</div>
                </div>
            </div>
            <div class="header-actions">
                <button class="btn btn-primary" onclick="openAddModal()">+ Add Book</button>
                <button class="btn btn-secondary" onclick="openReportsModal()">üìä Reports</button>
                <button class="btn btn-secondary" onclick="exportBooks()">
                    üíæ Export Backup
                </button>
                <button class="btn btn-secondary" onclick="document.getElementById('import-file').click()">
                    üìÇ Import Backup
                </button>
                <button class="btn btn-secondary" onclick="updateExistingSynopses()" id="update-synopses-btn">
                    üîÑ Update Synopses
                </button>
                <input type="file" id="import-file" accept=".json" style="display: none;" onchange="importBooks(event)">
            </div>
        </header>

        <!-- Controls -->
        <div class="controls">
            <div class="controls-row">
                <div class="search-box">
                    <input type="text" id="search-input" placeholder="Search by title or author..." oninput="handleSearch()">
                    <button class="search-clear" id="search-clear" onclick="clearSearch()">√ó</button>
                </div>
                <div class="filter-group">
                    <button class="filter-btn active" data-format="all" onclick="filterByFormat('all')">All</button>
                    <button class="filter-btn" data-format="physical" onclick="filterByFormat('physical')">Physical</button>
                    <button class="filter-btn" data-format="electronic" onclick="filterByFormat('electronic')">Electronic</button>
                    <button class="filter-btn" data-format="audio" onclick="filterByFormat('audio')">Audio</button>
                </div>
                <div class="filter-group">
                    <button class="filter-btn active" data-status="all" onclick="filterByStatus('all')">All Status</button>
                    <button class="filter-btn" data-status="read" onclick="filterByStatus('read')">Read</button>
                    <button class="filter-btn" data-status="planned" onclick="filterByStatus('planned')">Planning</button>
                </div>
                <select id="genre-filter" onchange="filterByGenre()">
                    <option value="all">All Genres</option>
                </select>
                <select id="sort-select" onchange="handleSort()">
                    <option value="date-desc">Newest First</option>
                    <option value="date-asc">Oldest First</option>
                    <option value="title">By Title</option>
                    <option value="author">By Author</option>
                </select>
                <button class="bulk-update-btn" id="bulk-update-btn" onclick="toggleBulkMode()">üìã Mark Planning as Read</button>
            </div>
        </div>

        <!-- Books Container -->
        <div id="books-container"></div>

        <!-- Bulk Action Bar -->
        <div id="bulk-action-bar" class="bulk-action-bar">
            <span class="selected-count"><span id="selected-count">0</span> book(s) selected</span>
            <input type="month" id="bulk-date-input" class="form-input" style="width: auto; padding: 8px 12px;" />
            <button class="btn btn-success" onclick="bulkMarkAsRead()">‚úì Mark as Read</button>
            <button class="btn btn-secondary" onclick="cancelBulkMode()">Cancel</button>
        </div>
    </div>

    <!-- Add/Edit Modal -->
    <div id="book-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Add Book</h2>
            </div>
            <div class="modal-body">
                <form id="book-form" onsubmit="handleSubmit(event)">
                    <div class="form-group">
                        <label class="form-label">Title <span class="required">*</span></label>
                        <input type="text" id="input-title" class="form-input" required>
                        <div class="error-message hidden" id="error-title">Title is required</div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Author <span class="required">*</span></label>
                        <input type="text" id="input-author" class="form-input" required>
                        <div class="error-message hidden" id="error-author">Author is required</div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Format <span class="required">*</span></label>
                        <div class="radio-group">
                            <div class="radio-option">
                                <input type="radio" id="format-physical" name="format" value="physical" required>
                                <label for="format-physical">Physical</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="format-electronic" name="format" value="electronic">
                                <label for="format-electronic">Electronic</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="format-audio" name="format" value="audio">
                                <label for="format-audio">Audio</label>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Date Read <span class="required">*</span></label>
                        <input type="month" id="input-date" class="form-input" required>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Genre <span class="required">*</span></label>
                        <input type="text" id="input-genre" class="form-input" required placeholder="e.g., Fiction, Mystery, Sci-Fi">
                        <div class="error-message hidden" id="error-genre">Genre is required</div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Cover Image URL (optional)</label>
                        <input type="url" id="input-cover" class="form-input" placeholder="https://..." oninput="previewCover()">
                        <div class="cover-preview hidden" id="cover-preview">
                            <img id="preview-img" src="" alt="Cover preview">
                        </div>
                    </div>

                    <div class="lookup-section">
                        <button type="button" class="btn lookup-btn" onclick="lookupBookInfo()" id="lookup-btn">
                            üîç Auto-fill Book Info
                        </button>
                        <div class="lookup-status" id="lookup-status"></div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Status <span class="required">*</span></label>
                        <div class="radio-group">
                            <div class="radio-option">
                                <input type="radio" id="status-read" name="status" value="read" required checked>
                                <label for="status-read">Read</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="status-planned" name="status" value="planned">
                                <label for="status-planned">Planning to Read</label>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Synopsis (optional)</label>
                        <textarea id="input-synopsis" class="form-input" maxlength="1000" oninput="updateCharCount()"></textarea>
                        <div class="char-count"><span id="char-count">0</span>/1000</div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button type="submit" form="book-form" class="btn btn-primary">Save Book</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="delete-modal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2>Delete Book</h2>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete "<strong id="delete-book-title"></strong>"?</p>
                <p style="color: var(--text-secondary); font-size: 0.875rem; margin-top: 10px;">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="closeDeleteModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmDelete()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Reports Modal -->
    <div id="reports-modal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2>üìä Dynamic Reading Reports</h2>
            </div>
            <div class="modal-body">
                <div class="report-controls">
                    <div class="control-group">
                        <label class="control-label">Primary Dimension</label>
                        <select id="primary-dimension" class="report-select" onchange="generateDynamicReport()">
                            <option value="format">Format</option>
                            <option value="genre">Genre</option>
                            <option value="year">Year</option>
                            <option value="month">Month</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Secondary Dimension (optional)</label>
                        <select id="secondary-dimension" class="report-select" onchange="generateDynamicReport()">
                            <option value="none">None - Single Dimension</option>
                            <option value="format">Format</option>
                            <option value="genre">Genre</option>
                            <option value="year">Year</option>
                            <option value="month">Month</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Filter by Status</label>
                        <select id="report-status-filter" class="report-select" onchange="generateDynamicReport()">
                            <option value="all">All Books</option>
                            <option value="read">Read Only</option>
                            <option value="planned">Planned Only</option>
                        </select>
                    </div>
                </div>
                <div id="dynamic-report-container"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="exportReportData()">üíæ Export Report</button>
                <button type="button" class="btn btn-primary" onclick="closeReportsModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let books = [];
        let editingBookId = null;
        let deletingBookId = null;
        let currentFilters = {
            format: 'all',
            genre: 'all',
            status: 'all',
            search: '',
            sort: 'date-desc'
        };
        let bulkModeActive = false;
        let selectedBooks = new Set();
        let previousStatusFilter = 'all';

        const STORAGE_KEY = 'bookTracker_books';

        // Auto-formatting to Proper Case
        function toProperCase(str) {
            // Words that should stay lowercase (unless at the start)
            const lowercaseWords = ['a', 'an', 'the', 'and', 'but', 'or', 'for', 'nor', 'on', 'at', 'to', 'from', 'by', 'of', 'in'];

            return str
                .toLowerCase()
                .split(' ')
                .map((word, index) => {
                    // Always capitalize first word
                    if (index === 0) {
                        return word.charAt(0).toUpperCase() + word.slice(1);
                    }
                    // Keep lowercase words lowercase unless they're the first word
                    if (lowercaseWords.includes(word)) {
                        return word;
                    }
                    // Capitalize other words
                    return word.charAt(0).toUpperCase() + word.slice(1);
                })
                .join(' ');
        }

        function formatTitleInput(input) {
            const cursorPos = input.selectionStart;
            const formatted = toProperCase(input.value);
            if (formatted !== input.value) {
                input.value = formatted;
                // Restore cursor position
                input.setSelectionRange(cursorPos, cursorPos);
            }
        }

        function formatAuthorInput(input) {
            const cursorPos = input.selectionStart;
            // For authors, capitalize each word (including "of", "the" etc)
            const formatted = input.value
                .toLowerCase()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');

            if (formatted !== input.value) {
                input.value = formatted;
                // Restore cursor position
                input.setSelectionRange(cursorPos, cursorPos);
            }
        }

        function formatGenreInput(input) {
            const cursorPos = input.selectionStart;
            // For genres, capitalize each word
            const formatted = input.value
                .toLowerCase()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');

            if (formatted !== input.value) {
                input.value = formatted;
                // Restore cursor position
                input.setSelectionRange(cursorPos, cursorPos);
            }
        }

        // Add auto-formatting event listeners
        function setupAutoFormatting() {
            const titleInput = document.getElementById('input-title');
            const authorInput = document.getElementById('input-author');
            const genreInput = document.getElementById('input-genre');

            // Format on blur (when user leaves the field)
            titleInput.addEventListener('blur', () => formatTitleInput(titleInput));
            authorInput.addEventListener('blur', () => formatAuthorInput(authorInput));
            genreInput.addEventListener('blur', () => formatGenreInput(genreInput));

            // Also format on Enter key
            [titleInput, authorInput, genreInput].forEach(input => {
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                        input.focus();
                    }
                });
            });
        }

        // Initialize
        function init() {
            loadBooks();
            updateStats();
            updateGenreFilter();
            renderBooks();
            setupAutoFormatting();

            // Set default date to current month
            const now = new Date();
            const currentMonth = now.toISOString().slice(0, 7);
            document.getElementById('input-date').value = currentMonth;
        }

        // LocalStorage Functions
        function loadBooks() {
            try {
                const data = localStorage.getItem(STORAGE_KEY);
                books = data ? JSON.parse(data) : [];
            } catch (e) {
                console.error('Failed to load books:', e);
                books = [];
            }
        }

        function saveBooks() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(books));

                // Auto-backup to localStorage with timestamp
                const backupKey = 'bookTracker_lastBackup';
                const backupData = {
                    timestamp: Date.now(),
                    books: books
                };
                localStorage.setItem(backupKey, JSON.stringify(backupData));

                return true;
            } catch (e) {
                console.error('Failed to save books:', e);
                alert('Storage limit exceeded. Please delete some books.');
                return false;
            }
        }

        // Book Management
        function addBook(bookData) {
            const book = {
                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                ...bookData,
                addedTimestamp: Date.now()
            };
            books.push(book);
            if (saveBooks()) {
                clearSearch(); // Clear search to show the new book
                updateStats();
                updateGenreFilter();
                renderBooks();
                closeModal();
            }
        }

        function updateBook(id, bookData) {
            const index = books.findIndex(b => b.id === id);
            if (index !== -1) {
                books[index] = { ...books[index], ...bookData };
                if (saveBooks()) {
                    clearSearch(); // Clear search to show the updated book
                    updateStats();
                    updateGenreFilter();
                    renderBooks();
                    closeModal();
                }
            }
        }

        function deleteBook(id) {
            books = books.filter(b => b.id !== id);
            if (saveBooks()) {
                updateStats();
                updateGenreFilter();
                renderBooks();
            }
        }

        // Export/Import Functions
        function exportBooks() {
            if (books.length === 0) {
                alert('No books to export!');
                return;
            }

            const dataStr = JSON.stringify(books, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });

            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(dataBlob);

            const now = new Date();
            const timestamp = now.toISOString().slice(0, 10).replace(/-/g, '');
            downloadLink.download = `book-tracker-backup-${timestamp}.json`;

            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            alert(`Successfully exported ${books.length} book(s)!\n\nBackup saved as: book-tracker-backup-${timestamp}.json`);
        }

        function importBooks(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedBooks = JSON.parse(e.target.result);

                    if (!Array.isArray(importedBooks)) {
                        throw new Error('Invalid backup file format');
                    }

                    // Validate book structure
                    const validBooks = importedBooks.filter(book =>
                        book.title && book.author && book.genre && book.format && book.dateRead
                    );

                    if (validBooks.length === 0) {
                        throw new Error('No valid books found in backup file');
                    }

                    const confirmed = confirm(
                        `Found ${validBooks.length} book(s) in backup file.\n\n` +
                        `Current library: ${books.length} book(s)\n\n` +
                        `Choose import option:\n` +
                        `OK = Replace current library\n` +
                        `Cancel = Merge with current library`
                    );

                    if (confirmed) {
                        // Replace
                        books = validBooks;
                    } else {
                        // Merge - check for duplicates
                        let addedCount = 0;
                        validBooks.forEach(importedBook => {
                            const exists = books.some(b =>
                                b.title === importedBook.title &&
                                b.author === importedBook.author &&
                                b.dateRead === importedBook.dateRead
                            );
                            if (!exists) {
                                books.push(importedBook);
                                addedCount++;
                            }
                        });

                        if (addedCount === 0) {
                            alert('No new books to import - all books already exist!');
                            return;
                        }

                        alert(`Added ${addedCount} new book(s) to your library!`);
                    }

                    saveBooks();
                    updateStats();
                    updateGenreFilter();
                    renderBooks();
                    clearSearch();

                    if (confirmed) {
                        alert(`Successfully imported ${validBooks.length} book(s)!\n\nYour library has been restored.`);
                    }

                } catch (error) {
                    alert(`Import failed: ${error.message}\n\nPlease make sure you're importing a valid book tracker backup file.`);
                }
            };

            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        // Modal Functions
        function openAddModal() {
            editingBookId = null;
            document.getElementById('modal-title').textContent = 'Add Book';
            document.getElementById('book-form').reset();
            document.getElementById('cover-preview').classList.add('hidden');
            document.getElementById('char-count').textContent = '0';

            // Set default date to current month
            const now = new Date();
            const currentMonth = now.toISOString().slice(0, 7);
            document.getElementById('input-date').value = currentMonth;

            document.getElementById('book-modal').classList.add('active');

            // Scroll modal to top and focus title field
            setTimeout(() => {
                const modalContent = document.querySelector('#book-modal .modal-content');
                if (modalContent) {
                    modalContent.scrollTop = 0;
                }
                document.getElementById('input-title').focus();
            }, 0);
        }

        function openEditModal(bookId) {
            editingBookId = bookId;
            const book = books.find(b => b.id === bookId);
            if (!book) return;

            document.getElementById('modal-title').textContent = 'Edit Book';
            document.getElementById('input-title').value = book.title;
            document.getElementById('input-author').value = book.author;
            document.getElementById('input-genre').value = book.genre;
            document.getElementById(`format-${book.format}`).checked = true;
            document.getElementById('input-cover').value = book.coverUrl || '';
            document.getElementById('input-date').value = book.dateRead;
            document.getElementById(`status-${book.status}`).checked = true;
            document.getElementById('input-synopsis').value = book.synopsis || '';
            updateCharCount();

            if (book.coverUrl) {
                document.getElementById('preview-img').src = book.coverUrl;
                document.getElementById('cover-preview').classList.remove('hidden');
            } else {
                document.getElementById('cover-preview').classList.add('hidden');
            }

            document.getElementById('book-modal').classList.add('active');

            // Scroll modal to top
            setTimeout(() => {
                const modalContent = document.querySelector('#book-modal .modal-content');
                if (modalContent) {
                    modalContent.scrollTop = 0;
                }
            }, 0);
        }

        function closeModal() {
            document.getElementById('book-modal').classList.remove('active');
            editingBookId = null;
        }

        function openDeleteModal(bookId) {
            deletingBookId = bookId;
            const book = books.find(b => b.id === bookId);
            if (!book) return;

            document.getElementById('delete-book-title').textContent = book.title;
            document.getElementById('delete-modal').classList.add('active');
        }

        function closeDeleteModal() {
            document.getElementById('delete-modal').classList.remove('active');
            deletingBookId = null;
        }

        function confirmDelete() {
            if (deletingBookId) {
                deleteBook(deletingBookId);
                closeDeleteModal();
            }
        }

        function openReportsModal() {
            generateDynamicReport();
            document.getElementById('reports-modal').classList.add('active');
        }

        function closeReportsModal() {
            document.getElementById('reports-modal').classList.remove('active');
        }

        function generateDynamicReport() {
            const primary = document.getElementById('primary-dimension').value;
            const secondary = document.getElementById('secondary-dimension').value;
            const statusFilter = document.getElementById('report-status-filter').value;

            // Filter books by status
            const filteredBooks = books.filter(book => {
                if (statusFilter === 'all') return true;
                return book.status === statusFilter;
            });

            const container = document.getElementById('dynamic-report-container');

            if (filteredBooks.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìä</div>
                        <h3>No data to display</h3>
                        <p>Add some books to see reports!</p>
                    </div>
                `;
                return;
            }

            if (secondary === 'none') {
                // Single dimension report
                renderSingleDimensionReport(filteredBooks, primary, container);
            } else if (primary === secondary) {
                // Same dimension selected for both
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                        <p>Please select different dimensions for primary and secondary analysis.</p>
                    </div>
                `;
            } else {
                // Multi-dimensional report
                renderMultiDimensionReport(filteredBooks, primary, secondary, container);
            }
        }

        function renderSingleDimensionReport(books, dimension, container) {
            const stats = {};
            const dimensionLabels = {
                format: { physical: 'Physical', electronic: 'Electronic', audio: 'Audio' },
                genre: {},
                year: {},
                month: {}
            };

            // Collect data
            books.forEach(book => {
                let key;
                switch(dimension) {
                    case 'format':
                        key = book.format;
                        break;
                    case 'genre':
                        key = book.genre || 'Unknown';
                        break;
                    case 'year':
                        key = book.dateRead.substring(0, 4);
                        break;
                    case 'month':
                        key = formatMonthYear(book.dateRead);
                        break;
                }
                stats[key] = (stats[key] || 0) + 1;
            });

            // Sort data
            let sortedStats;
            if (dimension === 'format') {
                sortedStats = [['physical', stats.physical || 0], ['electronic', stats.electronic || 0], ['audio', stats.audio || 0]];
            } else if (dimension === 'year' || dimension === 'month') {
                sortedStats = Object.entries(stats).sort((a, b) => b[0].localeCompare(a[0]));
            } else {
                sortedStats = Object.entries(stats).sort((a, b) => b[1] - a[1]);
            }

            const total = books.length;
            const title = dimension.charAt(0).toUpperCase() + dimension.slice(1);

            let html = `
                <div class="single-dimension-report">
                    <div class="report-section">
                        <h3>Books by ${title}</h3>
                        <div class="report-bars">
            `;

            sortedStats.forEach(([key, count]) => {
                const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : 0;
                const label = dimension === 'format' ? dimensionLabels.format[key] : key;

                html += `
                    <div class="report-item">
                        <div class="report-label">
                            <span class="report-genre-name">${escapeHtml(label)}</span>
                            <span class="report-count">${count} book${count !== 1 ? 's' : ''} (${percentage}%)</span>
                        </div>
                        <div class="report-bar-container">
                            <div class="report-bar ${dimension === 'format' ? key : ''}" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            });

            html += `
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        function renderMultiDimensionReport(books, primary, secondary, container) {
            // Create a matrix of data
            const matrix = {};
            const primaryKeys = new Set();
            const secondaryKeys = new Set();

            const getDimensionValue = (book, dimension) => {
                switch(dimension) {
                    case 'format':
                        return book.format;
                    case 'genre':
                        return book.genre || 'Unknown';
                    case 'year':
                        return book.dateRead.substring(0, 4);
                    case 'month':
                        return formatMonthYear(book.dateRead);
                }
            };

            const getDimensionLabel = (dimension, value) => {
                if (dimension === 'format') {
                    const labels = { physical: 'Physical', electronic: 'Electronic', audio: 'Audio' };
                    return labels[value];
                }
                return value;
            };

            // Collect data
            books.forEach(book => {
                const primaryValue = getDimensionValue(book, primary);
                const secondaryValue = getDimensionValue(book, secondary);

                primaryKeys.add(primaryValue);
                secondaryKeys.add(secondaryValue);

                if (!matrix[primaryValue]) {
                    matrix[primaryValue] = {};
                }
                matrix[primaryValue][secondaryValue] = (matrix[primaryValue][secondaryValue] || 0) + 1;
            });

            // Sort keys
            let sortedPrimaryKeys, sortedSecondaryKeys;

            if (primary === 'format') {
                sortedPrimaryKeys = ['physical', 'electronic', 'audio'].filter(k => primaryKeys.has(k));
            } else if (primary === 'year' || primary === 'month') {
                sortedPrimaryKeys = Array.from(primaryKeys).sort().reverse();
            } else {
                sortedPrimaryKeys = Array.from(primaryKeys).sort();
            }

            if (secondary === 'format') {
                sortedSecondaryKeys = ['physical', 'electronic', 'audio'].filter(k => secondaryKeys.has(k));
            } else if (secondary === 'year' || secondary === 'month') {
                sortedSecondaryKeys = Array.from(secondaryKeys).sort().reverse();
            } else {
                sortedSecondaryKeys = Array.from(secondaryKeys).sort();
            }

            const primaryTitle = primary.charAt(0).toUpperCase() + primary.slice(1);
            const secondaryTitle = secondary.charAt(0).toUpperCase() + secondary.slice(1);

            // Build table
            let html = `
                <div class="report-matrix">
                    <div class="report-matrix-title">Books by ${primaryTitle} √ó ${secondaryTitle}</div>
                    <div style="overflow-x: auto;">
                        <table class="matrix-table">
                            <thead>
                                <tr>
                                    <th>${primaryTitle} \ ${secondaryTitle}</th>
            `;

            sortedSecondaryKeys.forEach(key => {
                html += `<th>${escapeHtml(getDimensionLabel(secondary, key))}</th>`;
            });
            html += `<th>Total</th></tr></thead><tbody>`;

            // Data rows
            const columnTotals = {};
            let grandTotal = 0;

            sortedPrimaryKeys.forEach(primaryKey => {
                let rowTotal = 0;
                html += `<tr><td class="row-header">${escapeHtml(getDimensionLabel(primary, primaryKey))}</td>`;

                sortedSecondaryKeys.forEach(secondaryKey => {
                    const count = (matrix[primaryKey] && matrix[primaryKey][secondaryKey]) || 0;
                    html += `<td class="count-cell">${count || '-'}</td>`;
                    rowTotal += count;
                    columnTotals[secondaryKey] = (columnTotals[secondaryKey] || 0) + count;
                });

                html += `<td class="count-cell"><strong>${rowTotal}</strong></td></tr>`;
                grandTotal += rowTotal;
            });

            // Totals row
            html += `<tr class="total-row"><td>Total</td>`;
            sortedSecondaryKeys.forEach(key => {
                html += `<td class="count-cell"><strong>${columnTotals[key] || 0}</strong></td>`;
            });
            html += `<td class="count-cell"><strong>${grandTotal}</strong></td></tr>`;

            html += `</tbody></table></div></div>`;

            container.innerHTML = html;
        }

        function exportReportData() {
            const primary = document.getElementById('primary-dimension').value;
            const secondary = document.getElementById('secondary-dimension').value;
            const statusFilter = document.getElementById('report-status-filter').value;

            const filteredBooks = books.filter(book => {
                if (statusFilter === 'all') return true;
                return book.status === statusFilter;
            });

            if (filteredBooks.length === 0) {
                alert('No data to export!');
                return;
            }

            const reportData = {
                generatedAt: new Date().toISOString(),
                filters: {
                    primaryDimension: primary,
                    secondaryDimension: secondary,
                    statusFilter: statusFilter
                },
                totalBooks: filteredBooks.length,
                books: filteredBooks
            };

            const dataStr = JSON.stringify(reportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });

            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(dataBlob);

            const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
            downloadLink.download = `book-report-${timestamp}.json`;

            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            alert(`Report exported successfully!\n\nFile: book-report-${timestamp}.json`);
        }

        // Keep old function for backwards compatibility but it's not used anymore
        function generateReports() {
            // Calculate format statistics
            const formatStats = {
                physical: 0,
                electronic: 0,
                audio: 0
            };

            // Calculate genre statistics
            const genreStats = {};

            // Calculate year statistics
            const yearStats = {};

            // Calculate month statistics
            const monthStats = {};

            books.forEach(book => {
                // Count formats
                if (formatStats.hasOwnProperty(book.format)) {
                    formatStats[book.format]++;
                }

                // Count genres
                const genre = book.genre || 'Unknown';
                genreStats[genre] = (genreStats[genre] || 0) + 1;

                // Count by year
                const year = book.dateRead.substring(0, 4);
                yearStats[year] = (yearStats[year] || 0) + 1;

                // Count by month
                const monthYear = book.dateRead; // Format: YYYY-MM
                monthStats[monthYear] = (monthStats[monthYear] || 0) + 1;
            });

            // Render format report
            renderFormatReport(formatStats);

            // Render genre report
            renderGenreReport(genreStats);

            // Render year report
            renderYearReport(yearStats);

            // Render month report
            renderMonthReport(monthStats);
        }

        function renderFormatReport(formatStats) {
            const total = books.length;
            const formatLabels = {
                physical: 'Physical',
                electronic: 'Electronic',
                audio: 'Audio'
            };

            let html = '<div class="report-bars">';

            Object.keys(formatStats).forEach(format => {
                const count = formatStats[format];

                // Only show formats with at least 1 book
                if (count > 0) {
                    const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : 0;

                    html += `
                        <div class="report-item">
                            <div class="report-label">
                                <span class="report-genre-name">${formatLabels[format]}</span>
                                <span class="report-count">${count} book${count !== 1 ? 's' : ''} (${percentage}%)</span>
                            </div>
                            <div class="report-bar-container">
                                <div class="report-bar ${format}" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                }
            });

            html += '</div>';
            document.getElementById('format-report').innerHTML = html;
        }

        function renderGenreReport(genreStats) {
            const total = books.length;

            // Sort genres by count (descending)
            const sortedGenres = Object.entries(genreStats).sort((a, b) => b[1] - a[1]);

            let html = '<div class="report-bars">';

            sortedGenres.forEach(([genre, count]) => {
                const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : 0;

                html += `
                    <div class="report-item">
                        <div class="report-label">
                            <span class="report-genre-name">${escapeHtml(genre)}</span>
                            <span class="report-count">${count} book${count !== 1 ? 's' : ''} (${percentage}%)</span>
                        </div>
                        <div class="report-bar-container">
                            <div class="report-bar" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            document.getElementById('genre-report').innerHTML = html;
        }

        function renderYearReport(yearStats) {
            const total = books.length;

            // Sort years in descending order (most recent first)
            const sortedYears = Object.entries(yearStats).sort((a, b) => b[0].localeCompare(a[0]));

            let html = '<div class="report-bars">';

            sortedYears.forEach(([year, count]) => {
                const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : 0;

                html += `
                    <div class="report-item">
                        <div class="report-label">
                            <span class="report-genre-name">${year}</span>
                            <span class="report-count">${count} book${count !== 1 ? 's' : ''} (${percentage}%)</span>
                        </div>
                        <div class="report-bar-container">
                            <div class="report-bar" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            document.getElementById('year-report').innerHTML = html;
        }

        function renderMonthReport(monthStats) {
            const total = books.length;

            // Sort months in descending order (most recent first)
            const sortedMonths = Object.entries(monthStats).sort((a, b) => b[0].localeCompare(a[0]));

            let html = '<div class="report-bars">';

            sortedMonths.forEach(([monthYear, count]) => {
                const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : 0;
                const displayMonth = formatMonthYear(monthYear);

                html += `
                    <div class="report-item">
                        <div class="report-label">
                            <span class="report-genre-name">${displayMonth}</span>
                            <span class="report-count">${count} book${count !== 1 ? 's' : ''} (${percentage}%)</span>
                        </div>
                        <div class="report-bar-container">
                            <div class="report-bar" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            document.getElementById('month-report').innerHTML = html;
        }

        // Form Handling
        function handleSubmit(event) {
            event.preventDefault();

            const bookData = {
                title: document.getElementById('input-title').value.trim(),
                author: document.getElementById('input-author').value.trim(),
                genre: document.getElementById('input-genre').value.trim(),
                format: document.querySelector('input[name="format"]:checked').value,
                coverUrl: document.getElementById('input-cover').value.trim() || null,
                dateRead: document.getElementById('input-date').value,
                status: document.querySelector('input[name="status"]:checked').value,
                synopsis: document.getElementById('input-synopsis').value.trim() || null
            };

            if (editingBookId) {
                updateBook(editingBookId, bookData);
            } else {
                addBook(bookData);
            }
        }

        function previewCover() {
            const url = document.getElementById('input-cover').value.trim();
            const preview = document.getElementById('cover-preview');
            const img = document.getElementById('preview-img');

            if (url) {
                img.src = url;
                preview.classList.remove('hidden');
                img.onerror = () => {
                    preview.classList.add('hidden');
                };
            } else {
                preview.classList.add('hidden');
            }
        }

        function updateCharCount() {
            const textarea = document.getElementById('input-synopsis');
            const count = document.getElementById('char-count');
            count.textContent = textarea.value.length;
        }

        // Book Lookup with Multiple APIs
        async function lookupBookInfo() {
            const title = document.getElementById('input-title').value.trim();
            const author = document.getElementById('input-author').value.trim();

            if (!title || !author) {
                showLookupStatus('error', 'Please enter both title and author first');
                return;
            }

            const lookupBtn = document.getElementById('lookup-btn');
            lookupBtn.disabled = true;

            try {
                // Try 1: Google Books API (strict search)
                showLookupStatus('loading', '<span class="spinner"></span>Searching Google Books...');
                const googleResult = await searchGoogleBooks(title, author);
                if (googleResult) {
                    populateBookData(googleResult);
                    showLookupStatus('success', '‚úì Book info found (Google Books)');
                    return;
                }

                // Try 2: Open Library API
                showLookupStatus('loading', '<span class="spinner"></span>Searching Open Library...');
                const openLibResult = await searchOpenLibrary(title, author);
                if (openLibResult) {
                    populateBookData(openLibResult);
                    showLookupStatus('success', '‚úì Book info found (Open Library)');
                    return;
                }

                // Try 3: Internet Archive
                showLookupStatus('loading', '<span class="spinner"></span>Searching Internet Archive...');
                const archiveResult = await searchInternetArchive(title, author);
                if (archiveResult) {
                    populateBookData(archiveResult);
                    showLookupStatus('success', '‚úì Book info found (Internet Archive)');
                    return;
                }

                // Try 4: Google Books (broader search)
                showLookupStatus('loading', '<span class="spinner"></span>Trying broader search...');
                const googleBroadResult = await searchGoogleBooksBroad(title, author);
                if (googleBroadResult) {
                    populateBookData(googleBroadResult);
                    showLookupStatus('success', '‚úì Book info found (Broad Search)');
                    return;
                }

                // Try 5: Title-only search as last resort
                showLookupStatus('loading', '<span class="spinner"></span>Final search attempt...');
                const titleOnlyResult = await searchByTitleOnly(title);
                if (titleOnlyResult) {
                    populateBookData(titleOnlyResult);
                    showLookupStatus('success', '‚úì Partial info found - please verify');
                    return;
                }

                // No results from any API
                showLookupStatus('error', 'Book not found in 5 databases. Please fill details manually.');
            } catch (error) {
                console.error('Lookup error:', error);
                showLookupStatus('error', 'Search error occurred. Please try again or fill manually.');
            } finally {
                lookupBtn.disabled = false;
            }
        }

        // Search Google Books API
        async function searchGoogleBooks(title, author) {
            try {
                const query = `intitle:${encodeURIComponent(title)}+inauthor:${encodeURIComponent(author)}`;
                const url = `https://www.googleapis.com/books/v1/volumes?q=${query}&maxResults=1`;

                const response = await fetch(url);
                const data = await response.json();

                if (data.items && data.items.length > 0) {
                    const book = data.items[0].volumeInfo;
                    return {
                        genre: book.categories ? book.categories[0] : null,
                        coverUrl: book.imageLinks ? (book.imageLinks.thumbnail || book.imageLinks.smallThumbnail) : null,
                        synopsis: book.description ? summarizeSynopsis(book.description) : null
                    };
                }
            } catch (error) {
                console.error('Google Books error:', error);
            }
            return null;
        }

        // Search Open Library API
        async function searchOpenLibrary(title, author) {
            try {
                // Search by title and author
                const query = `title=${encodeURIComponent(title)}&author=${encodeURIComponent(author)}`;
                const url = `https://openlibrary.org/search.json?${query}&limit=1`;

                const response = await fetch(url);
                const data = await response.json();

                if (data.docs && data.docs.length > 0) {
                    const book = data.docs[0];

                    // Get book details including cover
                    let coverUrl = null;
                    if (book.cover_i) {
                        coverUrl = `https://covers.openlibrary.org/b/id/${book.cover_i}-L.jpg`;
                    }

                    // Get genre from subjects
                    let genre = null;
                    if (book.subject && book.subject.length > 0) {
                        genre = book.subject[0];
                    }

                    // Try to get detailed description if available
                    let synopsis = null;
                    if (book.first_sentence && book.first_sentence.length > 0) {
                        synopsis = book.first_sentence[0];
                    }

                    // If we have a work key, try to get full description
                    if (book.key) {
                        try {
                            const workUrl = `https://openlibrary.org${book.key}.json`;
                            const workResponse = await fetch(workUrl);
                            const workData = await workResponse.json();

                            if (workData.description) {
                                if (typeof workData.description === 'string') {
                                    synopsis = summarizeSynopsis(workData.description);
                                } else if (workData.description.value) {
                                    synopsis = summarizeSynopsis(workData.description.value);
                                }
                            }
                        } catch (e) {
                            // If work detail fetch fails, continue with what we have
                            console.log('Could not fetch work details:', e);
                        }
                    }

                    // Return data if we have at least something useful
                    if (coverUrl || genre || synopsis) {
                        return { genre, coverUrl, synopsis };
                    }
                }
            } catch (error) {
                console.error('Open Library error:', error);
            }
            return null;
        }

        // Search Internet Archive
        async function searchInternetArchive(title, author) {
            try {
                const query = `${title} ${author}`;
                const url = `https://archive.org/advancedsearch.php?q=${encodeURIComponent(query)}&fl=identifier,title,creator,subject,description&rows=1&page=1&output=json&mediatype=texts`;

                const response = await fetch(url);
                const data = await response.json();

                if (data.response && data.response.docs && data.response.docs.length > 0) {
                    const book = data.response.docs[0];

                    let coverUrl = null;
                    if (book.identifier) {
                        coverUrl = `https://archive.org/services/img/${book.identifier}`;
                    }

                    let genre = null;
                    if (book.subject && Array.isArray(book.subject) && book.subject.length > 0) {
                        genre = book.subject[0];
                    }

                    let synopsis = null;
                    if (book.description) {
                        const descText = Array.isArray(book.description) ? book.description[0] : book.description;
                        synopsis = summarizeSynopsis(descText);
                    }

                    if (coverUrl || genre || synopsis) {
                        return { genre, coverUrl, synopsis };
                    }
                }
            } catch (error) {
                console.error('Internet Archive error:', error);
            }
            return null;
        }

        // Search Google Books with broader criteria
        async function searchGoogleBooksBroad(title, author) {
            try {
                // Try a more flexible search - just combine title and author
                const query = encodeURIComponent(`${title} ${author}`);
                const url = `https://www.googleapis.com/books/v1/volumes?q=${query}&maxResults=3`;

                const response = await fetch(url);
                const data = await response.json();

                if (data.items && data.items.length > 0) {
                    // Try to find the best match
                    for (const item of data.items) {
                        const book = item.volumeInfo;
                        const bookTitle = book.title ? book.title.toLowerCase() : '';
                        const bookAuthor = book.authors ? book.authors.join(' ').toLowerCase() : '';

                        // Check if it's a reasonable match
                        if (bookTitle.includes(title.toLowerCase().substring(0, 10))) {
                            return {
                                genre: book.categories ? book.categories[0] : null,
                                coverUrl: book.imageLinks ? (book.imageLinks.thumbnail || book.imageLinks.smallThumbnail) : null,
                                synopsis: book.description ? summarizeSynopsis(book.description) : null
                            };
                        }
                    }
                }
            } catch (error) {
                console.error('Google Books Broad error:', error);
            }
            return null;
        }

        // Search by title only as last resort
        async function searchByTitleOnly(title) {
            try {
                // Try Google Books with just the title
                const query = `intitle:${encodeURIComponent(title)}`;
                const url = `https://www.googleapis.com/books/v1/volumes?q=${query}&maxResults=1`;

                const response = await fetch(url);
                const data = await response.json();

                if (data.items && data.items.length > 0) {
                    const book = data.items[0].volumeInfo;
                    return {
                        genre: book.categories ? book.categories[0] : null,
                        coverUrl: book.imageLinks ? (book.imageLinks.thumbnail || book.imageLinks.smallThumbnail) : null,
                        synopsis: book.description ? summarizeSynopsis(book.description) : null
                    };
                }
            } catch (error) {
                console.error('Title-only search error:', error);
            }
            return null;
        }

        // Populate form with book data
        function populateBookData(bookData) {
            if (bookData.genre) {
                document.getElementById('input-genre').value = bookData.genre;
                // Apply formatting to genre
                formatGenreInput(document.getElementById('input-genre'));
            }

            if (bookData.coverUrl) {
                // Use HTTPS for the image URL
                const httpsUrl = bookData.coverUrl.replace('http:', 'https:');
                document.getElementById('input-cover').value = httpsUrl;
                previewCover();
            }

            if (bookData.synopsis) {
                document.getElementById('input-synopsis').value = bookData.synopsis;
                updateCharCount();
            }
        }

        function showLookupStatus(type, message) {
            const statusEl = document.getElementById('lookup-status');
            statusEl.className = 'lookup-status ' + type;
            statusEl.innerHTML = message;

            // Auto-hide success/error messages after 5 seconds
            if (type !== 'loading') {
                setTimeout(() => {
                    statusEl.className = 'lookup-status';
                    statusEl.innerHTML = '';
                }, 5000);
            }
        }

        // Smart Synopsis Summarization
        function summarizeSynopsis(text, maxLength = 1000) {
            if (!text) return null;
            if (text.length <= maxLength) return text;

            // Try to find complete sentences up to maxLength
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
            let summary = '';

            for (const sentence of sentences) {
                if ((summary + sentence).length <= maxLength) {
                    summary += sentence;
                } else {
                    // If we haven't added any sentences yet, truncate the first one
                    if (summary.length === 0) {
                        summary = text.substring(0, maxLength - 3) + '...';
                    }
                    break;
                }
            }

            // If we got a good summary with complete sentences, return it
            if (summary.length > 0) {
                return summary.trim();
            }

            // Otherwise, just truncate at word boundary
            const truncated = text.substring(0, maxLength);
            const lastSpace = truncated.lastIndexOf(' ');
            if (lastSpace > maxLength * 0.8) {
                return truncated.substring(0, lastSpace) + '...';
            }

            return truncated + '...';
        }

        // Cover Generation
        function getDefaultCover(title) {
            const colors = [
                'var(--cover-1)',
                'var(--cover-2)',
                'var(--cover-3)',
                'var(--cover-4)',
                'var(--cover-5)'
            ];
            const colorIndex = title.charCodeAt(0) % colors.length;
            const letter = title.charAt(0).toUpperCase();

            return `<div style="background: ${colors[colorIndex]}; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 3rem; font-weight: 700; color: var(--text-primary);">${letter}</div>`;
        }

        function handleImageError(img, title) {
            const coverDiv = img.closest('.book-cover');
            if (coverDiv) {
                coverDiv.innerHTML = getDefaultCover(title);
            }
        }

        // Render Functions
        function renderBooks() {
            const container = document.getElementById('books-container');
            const filtered = getFilteredBooks();

            if (filtered.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìö</div>
                        <h3>No books found</h3>
                        <p>${books.length === 0 ? 'Click "Add Book" to start tracking your reading journey!' : 'Try adjusting your filters or search criteria.'}</p>
                    </div>
                `;
                return;
            }

            const grouped = groupByMonth(filtered);
            let html = '';

            grouped.forEach(group => {
                html += `
                    <div class="month-section">
                        <div class="month-header">
                            <h2 class="month-title">${group.display}</h2>
                            <span class="month-count">${group.books.length} book${group.books.length !== 1 ? 's' : ''}</span>
                        </div>
                        <div class="books-grid">
                            ${group.books.map(book => renderBookCard(book)).join('')}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function renderBookCard(book) {
            const coverHtml = book.coverUrl
                ? `<img src="${book.coverUrl}" alt="${escapeHtml(book.title)} cover" onerror="handleImageError(this, '${escapeHtml(book.title).replace(/'/g, "\\'")}')">`
                : getDefaultCover(book.title);

            const synopsis = book.synopsis || '';
            const truncatedSynopsis = synopsis.length > 150 ? synopsis.substring(0, 150) + '...' : synopsis;
            const needsToggle = synopsis.length > 150;

            // Show checkbox only in bulk mode and for planning books
            const showCheckbox = bulkModeActive && book.status === 'planned';
            const isChecked = selectedBooks.has(book.id);

            const checkboxHtml = showCheckbox
                ? `<div class="bulk-select-container active">
                       <input type="checkbox"
                              class="bulk-checkbox"
                              ${isChecked ? 'checked' : ''}
                              onchange="toggleBookSelection('${book.id}')" />
                   </div>`
                : '';

            return `
                <div class="book-card">
                    ${checkboxHtml}
                    <div class="book-cover">${coverHtml}</div>
                    <div class="book-content-wrapper">
                        <div class="book-title">${escapeHtml(book.title)}</div>
                        <div class="book-author">${escapeHtml(book.author)}</div>
                        <div class="book-meta">
                            <span class="badge badge-format ${book.format}">${formatBadgeText(book.format)}</span>
                            <span class="badge badge-genre">${escapeHtml(book.genre)}</span>
                            <span class="badge badge-date">${formatDate(book.dateRead)}</span>
                        </div>
                        ${synopsis ? `
                            <div class="book-synopsis">
                                <div class="synopsis-text" id="synopsis-${book.id}">${escapeHtml(truncatedSynopsis)}</div>
                                ${needsToggle ? `<button class="synopsis-toggle" onclick="toggleSynopsis('${book.id}', this)">Read more</button>` : ''}
                            </div>
                        ` : ''}
                    </div>
                    <div class="book-actions">
                        <button class="btn btn-small btn-success" onclick="openEditModal('${book.id}')">Edit</button>
                        <button class="btn btn-small btn-danger" onclick="openDeleteModal('${book.id}')">Delete</button>
                    </div>
                </div>
            `;
        }

        function toggleSynopsis(bookId, button) {
            const book = books.find(b => b.id === bookId);
            if (!book) return;

            const synopsisEl = document.getElementById(`synopsis-${bookId}`);
            const isExpanded = button.textContent === 'Read less';

            if (isExpanded) {
                const truncated = book.synopsis.substring(0, 150) + '...';
                synopsisEl.textContent = truncated;
                button.textContent = 'Read more';
            } else {
                synopsisEl.textContent = book.synopsis;
                button.textContent = 'Read less';
            }
        }

        // Data Processing
        function groupByMonth(booksList) {
            const groups = {};

            booksList.forEach(book => {
                const key = book.dateRead;
                if (!groups[key]) {
                    groups[key] = {
                        display: formatMonthYear(key),
                        books: [],
                        timestamp: new Date(key + '-01').getTime()
                    };
                }
                groups[key].books.push(book);
            });

            return Object.values(groups).sort((a, b) => b.timestamp - a.timestamp);
        }

        function getFilteredBooks() {
            return books.filter(book => {
                // Format filter
                if (currentFilters.format !== 'all' && book.format !== currentFilters.format) {
                    return false;
                }

                // Genre filter
                if (currentFilters.genre !== 'all' && book.genre !== currentFilters.genre) {
                    return false;
                }

                // Status filter
                if (currentFilters.status !== 'all' && book.status !== currentFilters.status) {
                    return false;
                }

                // Search filter
                if (currentFilters.search) {
                    const search = currentFilters.search.toLowerCase();
                    const titleMatch = book.title.toLowerCase().includes(search);
                    const authorMatch = book.author.toLowerCase().includes(search);
                    if (!titleMatch && !authorMatch) {
                        return false;
                    }
                }

                return true;
            }).sort((a, b) => {
                switch (currentFilters.sort) {
                    case 'date-desc':
                        return new Date(b.dateRead) - new Date(a.dateRead);
                    case 'date-asc':
                        return new Date(a.dateRead) - new Date(b.dateRead);
                    case 'title':
                        return a.title.localeCompare(b.title);
                    case 'author':
                        return a.author.localeCompare(b.author);
                    default:
                        return 0;
                }
            });
        }

        // Filter Functions
        function filterByFormat(format) {
            currentFilters.format = format;

            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-format="${format}"]`).classList.add('active');

            renderBooks();
        }

        function filterByGenre() {
            currentFilters.genre = document.getElementById('genre-filter').value;
            renderBooks();
        }

        function filterByStatus(status) {
            currentFilters.status = status;

            // Update button states
            document.querySelectorAll('[data-status]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-status="${status}"]`).classList.add('active');

            renderBooks();
        }

        let searchTimeout;
        function handleSearch() {
            clearTimeout(searchTimeout);
            const searchInput = document.getElementById('search-input');
            const clearBtn = document.getElementById('search-clear');

            // Show/hide clear button
            if (searchInput.value.trim()) {
                clearBtn.classList.add('visible');
            } else {
                clearBtn.classList.remove('visible');
            }

            searchTimeout = setTimeout(() => {
                currentFilters.search = searchInput.value.trim();
                renderBooks();
            }, 300);
        }

        function clearSearch() {
            const searchInput = document.getElementById('search-input');
            const clearBtn = document.getElementById('search-clear');

            searchInput.value = '';
            clearBtn.classList.remove('visible');
            currentFilters.search = '';
            renderBooks();
        }

        function handleSort() {
            currentFilters.sort = document.getElementById('sort-select').value;
            renderBooks();
        }

        // Bulk Update Mode Functions
        function toggleBulkMode() {
            bulkModeActive = !bulkModeActive;
            selectedBooks.clear();

            const btn = document.getElementById('bulk-update-btn');
            const actionBar = document.getElementById('bulk-action-bar');

            if (bulkModeActive) {
                // Store current status filter
                previousStatusFilter = currentFilters.status;

                // Auto-filter to planning books
                filterByStatus('planned');

                btn.classList.add('active');
                btn.textContent = '‚úì Exit Bulk Mode';

                // Set default date to current month
                const now = new Date();
                const currentMonth = now.toISOString().slice(0, 7);
                document.getElementById('bulk-date-input').value = currentMonth;
            } else {
                btn.classList.remove('active');
                btn.textContent = 'üìã Mark Planning as Read';
                actionBar.classList.remove('active');

                // Restore previous status filter
                filterByStatus(previousStatusFilter);
            }

            updateSelectedCount();
        }

        function toggleBookSelection(bookId) {
            if (selectedBooks.has(bookId)) {
                selectedBooks.delete(bookId);
            } else {
                selectedBooks.add(bookId);
            }
            updateSelectedCount();
        }

        function updateSelectedCount() {
            const count = selectedBooks.size;
            document.getElementById('selected-count').textContent = count;

            const actionBar = document.getElementById('bulk-action-bar');
            if (count > 0 && bulkModeActive) {
                actionBar.classList.add('active');
            } else {
                actionBar.classList.remove('active');
            }
        }

        function bulkMarkAsRead() {
            if (selectedBooks.size === 0) {
                alert('Please select at least one book to update.');
                return;
            }

            const dateRead = document.getElementById('bulk-date-input').value;
            if (!dateRead) {
                alert('Please select a date.');
                return;
            }

            // Collect book titles for confirmation
            const bookTitles = [];
            selectedBooks.forEach(bookId => {
                const book = books.find(b => b.id === bookId);
                if (book) {
                    bookTitles.push(`‚Ä¢ ${book.title}`);
                }
            });

            const confirmed = confirm(
                `Mark ${selectedBooks.size} book(s) as read with date ${formatMonthYear(dateRead)}?\n\n` +
                `Books to update:\n${bookTitles.join('\n')}`
            );

            if (!confirmed) return;

            let updatedCount = 0;
            const updatedTitles = [];

            selectedBooks.forEach(bookId => {
                const index = books.findIndex(b => b.id === bookId);
                if (index !== -1) {
                    updatedTitles.push(`‚Ä¢ ${books[index].title}`);
                    books[index].status = 'read';
                    books[index].dateRead = dateRead;
                    updatedCount++;
                }
            });

            if (saveBooks()) {
                alert(
                    `‚úì Successfully updated ${updatedCount} book(s) to "Read" status!\n\n` +
                    `Books marked as read:\n${updatedTitles.join('\n')}\n\n` +
                    `Date: ${formatMonthYear(dateRead)}`
                );
                selectedBooks.clear();
                cancelBulkMode();
                updateStats();
                renderBooks();
            }
        }

        function cancelBulkMode() {
            bulkModeActive = false;
            selectedBooks.clear();

            const btn = document.getElementById('bulk-update-btn');
            const actionBar = document.getElementById('bulk-action-bar');

            btn.classList.remove('active');
            btn.textContent = 'üìã Mark Planning as Read';
            actionBar.classList.remove('active');

            // Restore previous status filter
            filterByStatus(previousStatusFilter);
        }

        // Update Existing Book Synopses
        async function updateExistingSynopses() {
            const updateBtn = document.getElementById('update-synopses-btn');

            // Find books that likely have truncated synopses (exactly 500 chars or close to it)
            const booksToUpdate = books.filter(book => {
                if (!book.synopsis) return false;
                // Check if synopsis is exactly 500 chars (old limit) or ends abruptly
                return book.synopsis.length >= 490 && book.synopsis.length <= 500;
            });

            if (booksToUpdate.length === 0) {
                alert('All synopses are already up to date!');
                return;
            }

            const confirmed = confirm(
                `Found ${booksToUpdate.length} book(s) with potentially truncated synopses.\n\n` +
                `Would you like to fetch extended synopses for these books?\n\n` +
                `This will search online databases and may take a minute.`
            );

            if (!confirmed) return;

            // Disable button and show progress
            updateBtn.disabled = true;
            updateBtn.textContent = 'üîÑ Updating... (0/' + booksToUpdate.length + ')';

            let updated = 0;
            let failed = 0;

            for (let i = 0; i < booksToUpdate.length; i++) {
                const book = booksToUpdate[i];

                try {
                    // Try to fetch updated book data
                    const bookData = await fetchBookDataForUpdate(book.title, book.author);

                    if (bookData && bookData.synopsis && bookData.synopsis.length > book.synopsis.length) {
                        // Update the book's synopsis
                        const index = books.findIndex(b => b.id === book.id);
                        if (index !== -1) {
                            books[index].synopsis = bookData.synopsis;
                            updated++;
                        }
                    } else {
                        failed++;
                    }
                } catch (error) {
                    console.error(`Failed to update ${book.title}:`, error);
                    failed++;
                }

                // Update progress
                updateBtn.textContent = `üîÑ Updating... (${i + 1}/${booksToUpdate.length})`;
            }

            // Save updated books
            if (updated > 0) {
                saveBooks();
                renderBooks();
            }

            // Re-enable button and show results
            updateBtn.disabled = false;
            updateBtn.textContent = 'üîÑ Update Synopses';

            alert(
                `Synopsis Update Complete!\n\n` +
                `‚úì Updated: ${updated} book(s)\n` +
                `‚úó No update available: ${failed} book(s)`
            );
        }

        // Helper function to fetch book data for updates
        async function fetchBookDataForUpdate(title, author) {
            try {
                // Try Google Books first
                const googleResult = await searchGoogleBooks(title, author);
                if (googleResult && googleResult.synopsis) {
                    return googleResult;
                }

                // Try Open Library
                const openLibResult = await searchOpenLibrary(title, author);
                if (openLibResult && openLibResult.synopsis) {
                    return openLibResult;
                }

                // Try Internet Archive
                const archiveResult = await searchInternetArchive(title, author);
                if (archiveResult && archiveResult.synopsis) {
                    return archiveResult;
                }
            } catch (error) {
                console.error('Fetch error:', error);
            }
            return null;
        }

        // Statistics
        function updateStats() {
            const now = new Date();
            const currentMonth = now.toISOString().slice(0, 7);
            const currentYear = now.getFullYear().toString();

            // Total books
            document.getElementById('stat-total').textContent = books.length;

            // This month
            const thisMonth = books.filter(b => b.dateRead === currentMonth && b.status === 'read').length;
            document.getElementById('stat-month').textContent = thisMonth;

            // This year
            const thisYear = books.filter(b => b.dateRead.startsWith(currentYear) && b.status === 'read').length;
            document.getElementById('stat-year').textContent = thisYear;

            // Reading streak (consecutive months with at least one book read)
            const streak = calculateStreak();
            document.getElementById('stat-streak').textContent = streak;
        }

        function calculateStreak() {
            const readBooks = books.filter(b => b.status === 'read');
            if (readBooks.length === 0) return 0;

            const monthsWithBooks = new Set(readBooks.map(b => b.dateRead));
            const sortedMonths = Array.from(monthsWithBooks).sort().reverse();

            let streak = 0;
            const now = new Date();
            let checkDate = new Date(now.getFullYear(), now.getMonth(), 1);

            while (true) {
                const monthKey = checkDate.toISOString().slice(0, 7);
                if (sortedMonths.includes(monthKey)) {
                    streak++;
                    checkDate.setMonth(checkDate.getMonth() - 1);
                } else {
                    break;
                }
            }

            return streak;
        }

        function updateGenreFilter() {
            const genres = new Set(books.map(b => b.genre));
            const genreFilter = document.getElementById('genre-filter');
            const currentValue = genreFilter.value;

            genreFilter.innerHTML = '<option value="all">All Genres</option>';
            Array.from(genres).sort().forEach(genre => {
                const option = document.createElement('option');
                option.value = genre;
                option.textContent = genre;
                genreFilter.appendChild(option);
            });

            // Restore previous selection if still valid
            if (currentValue && genres.has(currentValue)) {
                genreFilter.value = currentValue;
            }
        }

        // Utility Functions
        function formatDate(dateStr) {
            const [year, month] = dateStr.split('-');
            const date = new Date(year, month - 1);
            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
        }

        function formatMonthYear(dateStr) {
            const [year, month] = dateStr.split('-');
            const date = new Date(year, month - 1);
            return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        }

        function formatBadgeText(format) {
            return format.charAt(0).toUpperCase() + format.slice(1);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Close modal on outside click
        document.getElementById('book-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });

        document.getElementById('delete-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeDeleteModal();
            }
        });

        document.getElementById('reports-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeReportsModal();
            }
        });

        // Initialize app
        init();
    </script>
</body>
</html>
